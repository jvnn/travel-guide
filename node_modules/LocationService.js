var fs = require('fs');

function LocationService() {

  var filterType = {
    LIMITS: 0,
    TAGS: 1
  }

  var toMeters = {
    "mi" : 1609.344,
    "km" : 1000,
    "m" : 1,
    "f" : 0.305
  }

  var fromMeters = {
    "mi" : 0.0006213711922373339,
    "km" : 0.001,
    "m" : 1,
    "f" : 3.281
  }

  var locations;
  var filename;
  var me = this;

  function readData(file, successCallback) {
    filename = file;
    fs.readFile(filename, 'utf-8', function(error, contents) {
      if (error == null) {
        locations = JSON.parse(contents)['locations'];
        successCallback();
      } else {
        console.log("Couldn't read data file: " + error);
      }
    });
  }

  function getLocationFilter(limitNorth, limitEast, limitSouth, limitWest) {
    return {
      type: filterType.LIMITS,
      north: limitNorth,
      east: limitEast,
      south: limitSouth,
      west: limitWest
    }
  }

  function getTagFilter(tags) {
    return {
      type: filterType.TAGS,
      tags: tags
    }
  }

  function query(filter) {
    if (filter == null) {
      // return copy
      return locations.slice();
    }

    switch (filter.type) {
      case filterType.LIMITS:
        return filterByLocation(filter);
      case filterType.TAGS:
        return filterByTags(filter);
    }

    return null;
  }

  function meanLocation(limits) {
    var locs = me.query(limits);
    var sum = 0;
    var lat = 0;
    var lon = 0;
    var minLon = 360;
    var maxLon = 0;
    locs.forEach(function(value) {
      var loc = getLocation(value);
      if (loc) {
        sum++;
        lat += loc['lat'];
        lon += loc['lon'];
        adjustedLon = 180 + loc['lon'];
        minLon = Math.min(adjustedLon, minLon);
        maxLon = Math.max(adjustedLon, maxLon);
      }
    });
    var zoomLevel = 360 / (maxLon - minLon);
    return {lat: lat/sum, lon: lon/sum, zoomRatio: zoomLevel};
  }

  function getLocation(item) {
    var loc = item['location'];
    if (loc && loc['lat'] && loc['lon']) {
      return loc;
    }
    return null;
  }

  function convertTo(source, unit) {
    var parts = source.split(' ');
    var value = parseFloat(parts[0]);
    var oldUnit = parts[1];
    var inMeters = value * toMeters[oldUnit];
    var inUnits = inMeters * fromMeters[unit];
    return inUnits;
  }

  function addLocation(name, description, tags, location) {
    var newItem = {name: name, description: description, location: location, tags: tags};
    locations.push(newItem);
    storeLocations();
    return newItem;
  }

  this.readData = readData;
  this.getLocationFilter = getLocationFilter;
  this.getTagFilter = getTagFilter;
  this.query = query;
  this.meanLocation = meanLocation;
  this.getLocation = getLocation;
  this.convertTo = convertTo;
  this.addLocation = addLocation;

  // private stuff

  function filterByLocation(limits) {
    return locations.filter(function(value, index, array) {
      var location = getLocation(value);
      if (!location) {
        return false;
      }

      var lat = location['lat'];
      var lon = location['lon'];

      if (lat < limits.south || lat > limits.north) {
        return false;
      }

      /* no matter what the area, we want to have a simple range from
       * 0 to x, and then check if lonDiff fits within that range */
      var lonRange = (360 + (limits.limitEast - limits.limitWest)) % 360;
      var lonDiff = (360 + (lon - limits.limitWest)) % 360;
      if (lonDiff < 0 || lonDiff > lonRange) {
        return false;
      }

      return true;
    });
  }

  function filterByTags(filter) {
    var tags = filter.tags;
  }

  function storeLocations() {
    var dataString = JSON.stringify({locations: locations});
    fs.writeFile(filename, dataString, function (err) {
      if (err) throw err;
    });
  }
}

module.exports = new LocationService;
